#include "json.hpp"
#include <fstream>
#include <iostream>
#include <regex>
#include <string>
#include <sys/stat.h>

// for convenience
using json = nlohmann::json;
using namespace std;

#include "math.h"
#include <opencv2/core/core.hpp>

struct Polygon {
  string name;
  vector<cv::Point2f> points;
};

inline bool exists_test(const string &name) {
  struct stat buffer;
  return (stat(name.c_str(), &buffer) == 0);
}

std::vector<std::string> split(std::string str, char delimiter) {
  std::vector<std::string> internal;
  std::stringstream ss(str); // Turn the string into a stream.
  std::string tok;

  while (getline(ss, tok, delimiter)) {
    internal.push_back(tok);
  }

  return internal;
}

// The JSON will contain the image name that it is annotated for.
typedef tuple<double, double, double> tilesize;
// The stiched image name: x_y_scale.png or x_y_scale.jpg
// e.g. /a/b/c/x_y_scale.png => [x, y, scale]
// * image name format: x-base_y-base_scale.png
tilesize parse_picture_name_to_coordinates(const string filepath) {
  vector<string> tokens = split(filepath, '/');
  string filename = tokens.at(tokens.size() - 3); // => "x_y_scale.jpg"
  string extensionless =
      filename.substr(0, filename.find_last_of(".")); // => "x_y_scale"
  vector<string> x_y_scale = split(extensionless, '_');

  // convert string to 3 double numbers
  double x_base = stod(x_y_scale.at(0));
  double y_base = stod(x_y_scale.at(1));
  double scale = stod(x_y_scale.at(2));
  return make_tuple(x_base, y_base, scale);
}

//   -  e.g. 96.246017_645.957214_461.35048.png
int main() {

  // read json file generated by vwd
  string json_file_path("index.json");

  if (!exists_test(json_file_path)) {
    cout << json_file_path << " path not found!" << endl;
    return -1;
  }

  ifstream in(json_file_path);
  json js;
  in >> js;

  string js_picture_name = js["name"];
  auto js_maybe_null_polygon_names = js["objects"];
  auto js_polygon_points = js["/frames/0/polygon"_json_pointer];

  cout << "js_picture_name: " << js_picture_name << endl;
  auto ts = parse_picture_name_to_coordinates(js_picture_name);
  cout << "x y scale coords: " << get<0>(ts) << " " << get<1>(ts) << " "
       << get<2>(ts) << endl;

  // when a polygon is deleted from the VWD web UI, the name becomes null
  // this filter out null name values
  vector<string> polygon_names;
  for (auto pn : js_maybe_null_polygon_names) {
    if (!pn.is_null()) {
      string s = pn["name"];
      polygon_names.push_back(s);
    }
  }
  cout << "# names:  " << polygon_names.size() << endl;

  cout << "# polygons:  " << js_polygon_points.size() << endl;

  if (polygon_names.size() != js_polygon_points.size()) {
    cerr << "ERROR: number of polygon names ( " << polygon_names.size()
         << ") does not match with number of polygons ("
         << js_polygon_points.size() << ")" << endl;
  }

  vector<Polygon> polygons;
  // check: names.size() == js_polygon_points.size()
  for (int i = 0; i < js_polygon_points.size(); ++i) {
    // check: js_polygon_points[i]["x"].size()
    // == js_polygon_points[i]["y"].size()
    auto n_points = js_polygon_points[i]["x"].size();
    Polygon p;
    p.name = polygon_names.at(i);

    for (int np = 0; np < n_points; ++np) {
      auto coord_x = js_polygon_points[i]["x"][np];
      auto coord_y = js_polygon_points[i]["y"][np];
      cv::Point2f xy(coord_x, coord_y);
      p.points.push_back(xy);
    }
    polygons.push_back(p);
  }

  for (auto &p : polygons) {
    cout << "polygon: \"" << p.name << "\" " << p.points.size() << " points\n";
  }

  // // write prettified JSON to another file
  // ofstream o("results.json");
  // o << j.dump() << endl;
  // ofstream pretty("results-pretty.json");
  // pretty << setw(4) << j << endl;
  // // results

  cout << "Exiting." << endl;
  return 0;
}
